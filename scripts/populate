#!/bin/bash
# Simple populate script: simply populates from a hard-wired list.
#
# Should be called with the following environment variables set:
#
: ${SYSROOT:?}          # Glibc sysroot from cross compiler
: ${sysroot:?}          # Root of rootfs being constructed
: ${install_list:?}     # File containing list of installed files
: ${STAGING_ROOT:?}     # Location of pre-installed packages

# The following environment variables are optional
#
#  EXTRA_LIBS             Extra libraries to be installed
#  CROSS_COMPILE          Must be set if cross compiling

# We have two notions of sysroot here.  $sysroot is the root of the *target*
# filesystem that we're building, while $SYSROOT defined here is the glibc
# sysroot: in effect we're copying $SYSROOT -> $sysroot.


HERE="$(dirname "$0")"
set -o pipefail


. "$HERE"/functions

READELF="$CROSS_COMPILE"readelf

LIB_SEARCH_PATH=("$STAGING_ROOT"/*)


# Searches for given library in lib and usr/lib, optionally searching for
# match to suffixes as well.  Called as:
#
#   locate_library <library> [<suffixes>]
#
locate_library()
{
    local lib="$1"
    shift

    local lib_dir lib_prefix
    for lib_prefix in "$SYSROOT" "${LIB_SEARCH_PATH[@]}"; do
        for lib_dir in lib lib64 usr/lib usr/lib64; do
            if (($#)); then
                for suffix; do
                    for file in "$lib_prefix/$lib_dir/$lib"$suffix; do
                        if [ -e "$file" ]; then
                            echo "$lib_dir/$(basename "$file")"
                            return 0
                        fi
                    done
                done
            else
                if [ -e "$lib_prefix/$lib_dir/$lib" ]; then
                    echo "$lib_dir/$lib"
                    return 0
                fi
            fi
        done
    done
    Error "Can't find library $lib"
}


# Outputs a list of all the library dependencies of the given executable
# files.  Called as
#
#   list_dependencies root files
#
list_dependencies()
{
    local root="$1"
    shift
    local file
    for file; do
        "$READELF" -d "$root/$file" |
        sed -n '/(NEEDED)/{s/^.*\[//; s/\].*$//; p; }' ||
            Error "Error reading file: $root/$file"
    done |
    sort | uniq |
    while read -r; do
        locate_library "$REPLY"  ||  exit 1
    done
}


# Given a library identified by locate_library returns the true path to that
# library.
library_path()
{
    local lib_prefix
    for lib_prefix in "$SYSROOT" "${LIB_SEARCH_PATH[@]}"; do
        if [ -e "$lib_prefix/$1" ]; then
            echo "$lib_prefix/$1"
            return 0
        fi
    done
    Error "That was unexpected"
}


# Installs the given libraries in the target system.
install_libs()
{
    local lib
    for lib; do
        lib_path="$(library_path "$lib")"  &&
        if [ -L "$lib_path" ]; then
            filename="$(readlink "$lib_path")"  &&
            mkdir -p "$sysroot/$(dirname $lib)" &&
            ln -s "$filename" "$sysroot/$lib"  &&
            lib="$(dirname "$lib")/$filename"
        fi  &&
        { [ -e "$sysroot/$lib" ]  ||
          mkdir -p "$sysroot/$(dirname $lib)" &&
          cp "$lib_path" "$sysroot/$lib"; }  &&
        do_strip "$sysroot/$lib"  &&
        chmod -w "$sysroot/$lib"  ||
            Error "Error installing libraries"
    done
}


# -----------------------------------------------------------------------------

# Resolve all the library dependencies.  From the list of installed files and
# the list of extra libraries we work out which libraries need to be installed
# for a working system.


# Compute the initial list of libraries.  This list is always maintained in
# order so that the set difference in the resolution loop below works.
LIBS="$(
    {
        # For all installed files we generate the list of libraries needed by
        # the loader.
        DEPENDENCIES="$(cat "$install_list")"  &&
        list_dependencies '' $DEPENDENCIES  &&

        # For all extra libraries we resolve the library name.  Here we search
        # quite hard for the file in question so that it does not have to be
        # specified too exactly.
        for lib in $EXTRA_LIBS; do
            locate_library $lib '' '.so.*' '.so' '-*.so'  ||  exit 1
        done
    } |
    sort | uniq )"  ||
    Error "Error finding libraries"

# This is the tricky bit.   ND is "new dependencies", we start with the entire
# library as dependencies, and only inspect genuinely new dependencies on each
# fresh round.
ND="$LIBS"
while [ -n "$ND" ]; do
    # Install all the libraries needed so far
    install_libs $ND

    # Discover all dependencies generated by the libraries we've just installed
    ND="$(list_dependencies "$sysroot" $ND | sort | uniq)"  ||
        Error Error resolving dependencies
    # Subtract from this list the libraries we've already installed
    ND="$(comm -13 <(echo "$LIBS") <(echo "$ND"))"
    # Finally add to the list of libraries and go around again.
    LIBS="$(sort <<<"$LIBS"$'\n'"$ND" | uniq)"
done
